<?php
namespace Inbenta\SmoochConnector\ExternalAPI;

use Exception;
use GuzzleHttp\Client as Guzzle;
use Psr\Http\Message\ResponseInterface;
use Symfony\Component\HttpFoundation\Request;

class SmoochAPIClient
{

    /**
     * The smooch API URL.
     *
     * @var string
     */
    protected $smooch = 'https://app.smooch.io/v1.1/';

    /**
     * The Smooch's Token.
     *
     * @var string|null
     */
    protected $jwt;

    /**
     * The Smooch user id.
     *
     * @var string|null
     */
    public $appUserId;

    /**
     * Create a new instance.
     *
     * @param string|null $jwt
     * @param string|null $request
     */

    /**
     * The Smooch app id.
     *
     * @var string|null
     */
    public $appId;

    public function __construct($jwt = null, $request = null)
    {
        $this->jwt = $jwt;
        // Messages from Smooch are json strings
        if (is_string($request)){
            $request = json_decode($request);
            if (isset($request->appUser) && isset($request->appUser->_id) && isset($request->trigger) && ($request->trigger == "postback" || $request->trigger == "message:appUser")) {
                //Save Smooch appUserId
                $this->appUserId = $request->appUser->_id;
                $this->appId = $request->app->_id;
            }
        // Messages from Hyperchat are arrays
        }else{
            return;
        }
    }

    /**
     * Send an outgoing message.
     *
     * @param array $message
     * @return \Psr\Http\Message\ResponseInterface
     */
    public function send($message)
    {
        $response = $this->smooch('POST', 'apps/' . $this->appId . '/appusers/' . $this->appUserId . '/messages', [
            'json' => $message,
        ]);
        return $response;
    }

    /**
     * Send a request to the Smooch Graph API.
     *
     * @param string $method
     * @param string $uri
     * @param array $options
     * @return ResponseInterface
     */
    protected function smooch($method, $uri, array $options = [])
    {
        if (is_null($this->jwt)) {
            throw new Exception('JWT is not defined');
        }

        $guzzle = new Guzzle([
            'base_uri' => $this->smooch,
        ]);

        $response = $guzzle->request($method, $uri, array_merge_recursive($options, [
            'headers' => [
                'Authorization' => "Bearer " . $this->jwt
            ]
        ]));
        return $response;
    }

    /**
    *   Establishes the Smooch sender (user) directly with the provided ID
    */
    public function setSenderFromId($externalUserId, $externalAppId)
    {
        $this->appUserId = $externalUserId;
        $this->appId = $externalAppId;
    }

    /**
    *   Returns the full name of the user (first + last name)
    */
    public function getFullName()
    {
        $response = $this->smooch('GET', "apps/" . $this->appId ."/appusers/" . $this->appUserId);
        $responseBody = json_decode($response->getBody()->getContents());
        $name = $responseBody->appUser->givenName . ' ' . $responseBody->appUser->surname;
        return $name;
    }

    /**
    *   Generates the external id used by HyperChat to identify one user as external.
    *   This external id will be used by HyperChat adapter to instance this client class from the external id
    */
    public function getExternalId()
    {
        return 'smooch-' . $this->appId . '-' . $this->appUserId;
    }

    /**
    *   Retrieves the user id from the external ID generated by the getExternalId method
    */
    public static function getIdFromExternalId($externalId)
    {
        $smoochInfo = explode('-', $externalId);
        if (array_shift($smoochInfo) == 'smooch') {
            return $smoochInfo[1];
        }
        return null;
    }

    /**
    *   Retrieves the user id from the external ID generated by the getExternalId method
    */
    public static function getAppIdFromExternalId($externalId)
    {
        $smoochInfo = explode('-', $externalId);
        if (array_shift($smoochInfo) == 'smooch') {
            return $smoochInfo[0];
        }
        return null;
    }

    public static function buildExternalIdFromRequest()
    {
        $request = json_decode(file_get_contents('php://input'));
        if (isset($request->appUser) && isset($request->appUser->_id) && isset($request->trigger)) {
            return 'smooch-' . $request->app->_id . '-' . $request->appUser->_id;
        }
        return null;
    }


    public function getEmail()
    {
        return $this->getExternalId()."@smooch.com";
    }

    /**
    *   Sends a flag to Smooch to display a notification alert as the bot is 'writing'
    *   This method can be used to disable the notification if a 'false' parameter is received
    */
    public function showBotTyping($show = true)
    {
        $action = $show ? 'start' : 'stop';
        return $this->smooch('POST', 'apps/' . $this->appId . '/appusers/' . $this->appUserId . '/conversation/activity', [
            'json' => [
                'role' => 'appMaker',
                'type' => 'typing:' . $action
            ]
        ]);
    }

    /**
    *   Sends a message to Smooch. Needs a message formatted with the Smooch notation
    */
    public function sendMessage($message)
    {
        $this->showBotTyping(true);
        $messageSend = $this->send($message);
        $this->showBotTyping(false);
        return $messageSend;
    }

    /**
    *   Sends a message to Smooch. Needs a message formatted with the Smooch notation
    */
    public function sendMultipleMessage($messages, $messageSend = null)
    {
        if(count($messages) > 0){
            $this->showBotTyping(true);
            $messageSend = $this->send($messages[0]);
            if($messages[0]["type"] === "image") sleep(2);
            if ((int)$messageSend->getStatusCode() > 200 &&
                (int)$messageSend->getStatusCode() < 400){
                array_shift($messages);
                $this->sendMultipleMessage($messages, $messageSend);
            }
        }else{
            $this->showBotTyping(false);
            return $messageSend;
        }
    }

    /**
    *   Generates a text message from a string and sends it to Smooch
    */
    public function sendTextMessage($text)
    {
        $this->sendMessage(array(
                'role' => 'appMaker',
                'type' => 'text',
                'text' => strip_tags($text)
        ));
    }

    /**
     *   Generates a Smooch attachment message from HyperChat message
     */
    public function sendAttachmentMessageFromHyperChat($message)
    {
        $type = strpos($message['type'], 'image') !== false ? 'image' : 'file';
        $this->sendMessage([
            'type' => $type,
            'role' => 'appMaker',
            'mediaUrl' => $message['fullUrl']
        ]);
    }
}
